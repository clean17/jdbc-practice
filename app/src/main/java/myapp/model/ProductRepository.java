/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package myapp.model;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;

import myapp.config.DB;

public class ProductRepository {
    // Connection conn ; // 전역변수로 만든다 // 으로 만들면 하나밖에 못만든다 - 여러스레드에서 사용하지 못한다 .. 응 ?
    private Connection conn;
    
    // 해결책으로 싱글톤을 이용한다 
    // private static ProductRepository instance = new ProductRepository();
    
    // public static ProductRepository getInstance(){
    //     return instance;
    // }

    // // 싱글톤 생성자 사용 금지
    // private ProductRepository(){    
    // }

    // public static void main(String[] args) throws Exception{

    //     // Connection conn = DB.getConnection(); 커넥션이 메소드 안에 있으면 사라지니까 전역변수로 뺀건가 ?

    //     // 전역변수를 사용하기 위해 객체 생성
    //     App app = new App(); // 원래 이 클래스 이름이 app
    //     app.conn = DB.getConnection();
    //     insert("apple",500, 10);  // 만들어진 메소드의 문제는 커넥션이 반복해서 생성 삭제가 이루어진다. 자원소모
    //     insert("raspberry", 2000, 50);
    //     app.conn.close(); // 이동한 커넥션을 여기서 종료함
    // }

    // 지금메소드를 모듈로 만들어보자 -> Refactor
    private void insert(String name, int price, int qty) throws SQLException {
        // 1 커넥션 객체 만들기
      //  Connection conn = DB.getConnection();  이동되었음

        // 2 버퍼 접근
        String sql = "insert into product(name, price, qty, created_at) values (?,?,?,now())";
        PreparedStatement pstmt = conn.prepareStatement(sql);

        // 3 물음표 완성
        pstmt.setString(1, name); // 첫번째 물음표에 대입
        pstmt.setInt(2, price);
        pstmt.setInt(3, qty);
        
        // PreparedStatement 를 사용하면 or -- 같은 인젝션 공격을 막아준다. 변수 바인딩이 편하다  "1 OR 1=1 --"
        // db 인젝션을 더 알아봐

        // 4 전송
        // pstmt.addBatch(); // 모든 데이터를 한번에 보낸다
        int result = pstmt.executeUpdate();

        // 5 응답에 대한 처리
        if( result == 1 ){
            System.out.println("insert 되었습니다.");
        }else{
            System.out.println("insert 실패");
        }

        // 뒤처리 필요없는 연결 종료.. pooling을 사용하면 알아서 해줌
        // 지금은 연결이 스택에 만들었으니 ( 메소드 안에 ) 메소드 종료시에 자동적으로 사라진다
        // 클래스에 만들었다면 힙에 생성되므로 직접 종료해야한다
        
        pstmt.close();
    }

    

    
}
